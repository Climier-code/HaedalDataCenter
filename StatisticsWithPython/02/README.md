# 02. 파이썬과 주피터 노트북 기초

## 1. 아나콘다와 주피터 노트북
아나콘다는 
주피터 노트북은 

~설치방법~


## 2. 파이썬 기초

### 2.1. 연산자
#### 2.1.1 산술 연산자  
|연산자|연산|
|:---:|-----|
|+|두 수를 더한다.|
|-|왼쪽의 수에서 오른쪽의 수를 뺀다.|
|*|두 수를 곱한다.|
|/|왼쪽의 수를 오른쪽의 수로 나눈다.|
|**|왼쪽의 수를 밑, 오른쪽의 수를 지수로 하여 거듭제곱한다.|
|//|왼쪽의 수를 오른쪽의 수로 나눈 뒤 소수점 이하의 값을 버림한다.|

#### 2.1.2. 비교 연산자
|연산자|연산|
|:---:|-----|
|>|왼쪽이 오른쪽보다 크다.|
|>=|왼쪽이 오른쪽보다 크거나 같다.|
|<|왼쪽이 오른쪽보다 작다.|
|<=|왼쪽이 오른쪽보다 작거나 같다.|
|==|양쪽이 같다.|
|!=|양쪽이 다르다.|

### 2.2. 데이터형
|데이터형|설명|
|:---:|-----|
|int|정수형|
|str|문자열형|
|float|부동소수점형|
|bool|부울형|

### 2.3. 함수
계산 로직(처리)을 저장해놓은 것을 함수 또는 메서드라고 부른다. 함수의 기본적인 형태는 다음과 같다.

```python
def 함수명(인수):
    처리
```

두 인수를 받아와 더한 값을 반환하는 함수는 아래와 같이 작성할 수 있다.

```python
def add_a_to_b(a, b):
    return a+b

add_a_to_b(10, 20)
```

인수 a의 값은 10, b의 값은 20이 되어, 반환된 값은 10 + 20의 결과값이 된다.

```
30
```

### 2.4. 클래스와 인스턴스
데이터의 구조와 계산 로직을 하나로 묶어둔 것이 클래스이다. 다른 표현으로는 속성(attribute)과 행위(behavior)를 가진 것이라고 설명할 수 있겠다.
속성은 멤버 변수에 대응되는 개념이고 행위는 메서드와 대응한다고 보면 된다.
클래스의 기본 형태는 다음과 같다.

```python
class 클래스명:
    def __init__(self, 인수):
        초기화
    def 함수명(인수):
        처리
```

사람의 일부 속성과 행위만을 따와서 Human 클래스를 만들어보겠다. 이때 따오는 기준은 필요성이 되겠다.
속성으로 이름, 나이, 성별, 신장, 체중을 갖고, 행위로는 식사와 자기소개를 하는 Human 클래스는 아래처럼 만들 수 있다.

```python
class Human:
    def __init__(self, name, age, sex, height, weight):
        self.name = name
        self.age = age
        self.sex = sex
        self.height = height
        self.weight = weight
    def eating(food):
        self.weight += 0.1
    def introduce():
        print("hi my name is"+name)
```

이 클래스의 인스턴스를 만들면 다음과 같다. 클래스와 인스턴스의 관계는 흔히 붕어빵틀과 붕어빵의 관계로 은유되곤 한다.

```python
human01 = Human(name="김철수", age=51, sex="male", height=173, weight=71.3)

human01.introduce()
human01.eating("라면")
human01.weight
```

실행 결과는 이렇다.

```
hi my name is 김철수
71.4
```

### 2.5. 조건문
특정 조건을 만족할 때만 특정한 처리를 하고 싶을 때 if문을 사용한다. if문의 기본적인 형태는 다음과 같다.

```python
if 조건식 : 
    처리
```

아래의 예시를 보자.

```python
a = 10
b = 20

if b % a == 0 :
    print("b는 a의 정수배다.")
else :
    print("b는 a의 정수배가 아니다.")

```

조건식으로 주어진 것은 b와 a의 mod연산이다. 위의 연산자 표를 참고하면 알 수 있겠지만, b를 a로 나누었을 때 나머지를 의미한다.
나머지가 0이라는 것은 b가 0이거나 b/a 연산이 나누어 떨어진다는 뜻이다. 위의 조건식은 참이 되며 실제로도 b는 a*2이다.

```python
a = 10
b = 10

if a % b == 0 :
    print("a는 b의 정수배다.")
else if b % a == 0 :
    print("b는 a의 정수배다.")
else :
    print("a는 b의 정수배가 아니며 b도 a의 정수배가 아니다.")
```

else 블록 말고도 else if 블록이 있다. if문을 여러개 쓰지 않고 else if 블록을 사용하면, 위에서부터 순서대로 조건식을 따져 봤을 때,
참인 블록이 있다면 그것만 실행하고 아래 딸린 블록들은 전부 무시된다. 여기서는 a%b == 0, b%a == 0 둘 다 참이지만, 더 위에 있는 
a%b == 0인 블록만 실행되고 else if 부분은 실행되지 않는다. 따라서 결과는 아래와 같이 나온다.

```
a는 b의 정수배다.
```

### 2.6. 반복문
같은 처리를 반복 수행하는 경우 for문으로 간단하게 구현할 수 있다. for문의 기본적인 형태는 아래와 같다.

```python
for 변수 in 리스트 : 
    처리
```

예를 들어 A를 여러 번 출력하고 싶다면 다음과 같이 코드를 작성할 수 있다.

```python
for i in range(5):
    print("A")
```

range는 주어진 인수에 따라 리스트를 만든다. range(5)는 [0, 1, 2, 3, 4]인 리스트가 된다.
실행 결과는 아래와 같다.

```
A
A
A
A
A
```

## 3. numpy와 pandas 사용하기
numpy와 pandas는 외부 패키지로 데이터 읽기, 가공하기 등의 연산들을 제공한다. 아나콘다에는 기본적으로 numpy와 pandas가 포함되어 있으므로
설치하는 법은 생략하도록 하겠다.

### 3.1. numpy 기초
#### 3.1.1. 배열
numpy에서 제공하는 array 함수를 이용하면 배열을 만들 수 있다.

```python
import numpy as np

sample_array = np.array([1, 2, 3, 4, 5])
```

array 함수는 인수로 리스트가 필요하다.   


배열을 대상으로 하는 연산은 배열 내부 데이터 전부에 적용된다. 다음의 예시를 보자.

```python
sample_array + 10
```

이렇게 배열에 10을 더하는 연산의 결과는 아래와 같이 나온다.

```
array([11, 12, 13, 14, 15])
```

각 배열의 요소들에 전부 10이 더해진 모습이다.  

한 배열 내부의 요소들은 데이터형이 전부 같아야 한다. 만약 서로 다른 데이터형이 있는 리스트가 주어지면 한 가지 데이터형으로 통일된다.

```python
sample_array = np.array([1, 2, 'A', 'B'])
```

이렇게 정수와 문자열이 같이 들어가게 되면,

```
array(['1', '2', 'A', 'B'])
```

정수까지 문자열로 자동 변환된다.

일일히 리스트 값을 입력하지 않고도, 규칙적/반복적 데이터들이 있는 배열을 자동으로 만들 수도 있다.
일례로 arrange 함수는 첫 번째 항과 종료할 값, 공차를 인수로 받아 등차수열 배열을 만들어주는 함수이다.

```python
np.arange(start=1, stop=6, step=1)
```

이 코드의 결과는 1부터 시작해서 6이 되기 전까지, 1씩 차이가 나는 정수들로 이루어진 배열이다.

```
array([1, 2, 3, 4, 5])
```

tile 함수는 같은 값으로 이루어진 배열을 자동으로 만들어주는 함수이다. 만약 문자 'A'가 5개 있는 배열을 만든다고 하면,

```python
np.tile('A', 5)
```

이렇게 코드를 작성할 수 있고, 그 결과는 아래와 같다.

```
array(['A', 'A', 'A', 'A', 'A'])
```

tile 함수도 사용할 수 있으나, 0으로만 또는 1로만 이루어진 배열은 각각 zeros, ones 함수로 더 간단하게 만들 수가 있다.

```python
zeros_arr = np.zeros(4)
ones_arr = np.ones(4)

print(zeros_arr)
print(ones_arr)
```

결과는 다음과 같다.

```
array([0, 0, 0, 0])
array([1, 1, 1, 1])
```

#### 3.1.2. 슬라이싱
numpy의 배열에서 특정 값을 따로 추출해내는 방법에 대해서 알아보자.

```python
import numpy as np

arr_2d = np.array([[1, 2, 3], [10, 20, 30]])
```

이렇게 이차원 배열 arr_2d에서 하나의 값을 추출하려면,

```python
print(arr_2d[1, 1])
```

옆에 [행, 열] 값을 주면 된다. 1행 1열의 값은 20이므로 결과는 20이다.


```python
print(arr_2d[0, 1:3])
```

또는 이렇게 범위를 지정해서 데이터를 가져올 수도 있다. 위의 코드는 arr_2d 0행의 1열부터 3-1개의 데이터를 가져오는 예시이다.
결과는 아래와 같다.

```
array([2, 3])
```

### 3.2. pandas 기초
#### 3.2.1. 데이터프레임 다루기
pandas를 이용하여 데이터프레임을 만드는 방법에 대해 알아보자.

```python
import pandas as pd

sample_df = pd.DataFrame({'col01': [1, 2, 3, 4, 5], 'col02': ['A', 'B', 'C', 'D', 'E']})
```

가장 간단하게는 이렇게 열 이름과 열에 들어갈 데이터를 리스트로 넘겨 주는 방식이 있다.
이렇게 해서 만들어진 데이터 프레임은 아래와 같다.

|-|col01|col02|
|:---:|:---:|:---:|
|0|1|A|
|1|2|B|
|2|3|C|
|3|4|D|
|4|5|E|


또는 read_csv 함수를 이용해서 csv파일을 읽어와 자동으로 데이터프레임을 만들 수도 있다.

두 데이터프레임을 병합하는 처리는 concat 함수를 통해 할 수 있다. concat 함수로 데이터프레임을 이어 주면, 세로 방향(아래쪽)으로 데이터프레임이 붙어 나온다.
인수로는 이을 데이터프레임들로 이루어진 리스트를 받는다.

```python
sample_df = pd.DataFrame({'col01': [100, 300], 'col02': ['가', '나']})

pd.concat([sample_df, sample_df02])
```

|-|col01|col02|
|:---:|:---:|:---:|
|0|1|A|
|1|2|B|
|2|3|C|
|3|4|D|
|4|5|E|
|5|100|가|
|6|300|나|


세로가 아닌 가로 방향으로 이어붙이고 싶은 경우에는 아래와 같이 코드를 작성한다.

```python
pd.concat([sample_df, sample_df02], axis=1)
```

|-|col01|col02|col01|col02|
|:---:|:---:|:---:|:---:|:---:|
|0|1|A|100|가|
|1|2|B|300|나|
|2|3|C|NaN|NaN|
|3|4|D|NaN|NaN|
|4|5|E|NaN|NaN|


데이터프레임에서 하나의 열만 가져오는 방법도 있는데,

```python
print(sample_df.col01)
```

이렇게 데이터프레임에 점(.)을 붙인 후 추출할 열 이름을 지정하는 방법이 있고,

```python
print(sample_df['col01'])
```

이렇게 대괄호를 이용하는 방법도 있다. 이렇게 추출된 결과는 특정한 열(col01)만 가진 데이터프레임이다.  

반대로 특정한 열만 제외한 데이터프레임을 만드는 것은 drop 함수를 이용해서 할 수 있다.

```python
print(sample_df.drop('col01', axis=1))
```

이 코드는 sample_df에서 col01 열이 사라진 데이터프레임을 출력한다.

열이 아닌 행에 대한 작업은 head 함수 또는 query문을 이용해서 할 수 있다.

```python
print(sample_df.head(n=3))
```

head 함수는 0번째 행부터 출력할 행의 개수를 받는다.

```python
print(sample_df.query('index == 0'))
```

query 함수는 쿼리문을 받아서 조건에 맞는 행만 가져온다. 위의 코드는 데이터프레임에서 인덱스가 0인 행만 가져오는 것이다.
이 밖에도 여러 조건을 붙일 수 있다.

```python
print(sample_df.query('col01 == 2 | col02 == "C"'))
```

위의 코드는 col01의 값이 2인 행 또는 col02의 값이 C인 행을 가져온다. 실행 결과는 다음과 같다.

|-|col01|col02|
|:---:|:---:|:---:|
|1|2|B|
|2|3|C|

행에 조건을 걺과 동시에 열에도 조건을 걸어줄 수도 있다.

```python
print(sample_df.query('col01 == 3')['col02'])
```

이 코드는 col01의 값이 3인 행의 col02열을 가져온다. 결과는 아래와 같다.

|-|col02|
|:---:|:---:|
|2|C|

#### 3.2.2. 시리즈
pandas 데이터프레임에서 1열만 추출하면 시리즈라는 열 데이터형으로 바뀐다. 

```python
type(sample_df.col01)
```

위에서 다뤘듯 sample_df.col01의 결과는 col01 열이다. 이것이 어떤 클래스에 속하는지 확인해보자.

```
pandas.core.series.Series
```

시리즈라는 클래스임을 확인했다.   

시리즈는 numpy 배열과 거의 유사하지만, 배열이 좀 더 사용이 편하므로 배열로 변환해주는 게 낫다.
numpy의 array 함수의 인수로 시리즈를 주거나, 시리즈형 변수에 .value를 붙이면 배열이 추출된다.
